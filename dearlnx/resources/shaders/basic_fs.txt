#version 330 core

in VS_OUT {
  float time;
} fs_in;

out vec4 color;
uniform float resx;
uniform float resy;
uniform sampler2D sampler0;
uniform vec3 camheading;
uniform vec3 camright;
uniform vec3 camup;
uniform vec3 campos;

float dfSphere(vec3 p, float s) {
  return length(p) - s;
}

float sdPlane( vec3 p, vec4 n )
{
  // n must be normalized
  return dot(p,n.xyz) + n.w;
}

float sdSphere( vec3 p, float s )
{
  return length(p)-s;
}

float sdTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

float dist(vec3 rayPos, vec3 objPos) {
  vec3 p = rayPos - objPos;
  //return min( dfSphere(p, 16), sdPlane( rayPos, vec4(0.0,1.0,0.0,0.0) ) );
  //return sdPlane( rayPos, vec4(0.0,1.0,0.0,0.0) );
	return min( sdSphere( rayPos, 5 ), sdPlane( rayPos, vec4(0.0,1.0,0.0,0.0)) );
}

float doLight(vec3 vd, vec3 p, vec3 n, vec3 lightPos) {
  vec3 ld = normalize(lightPos - p);      
  float specular = pow(clamp(dot(vd, reflect(ld, n)), 0, 1), 16) * 30 / length(lightPos - p);
  return specular + 0.25 * clamp(dot(ld, n), 0, 1);
}

void main() {
  //float x = (gl_FragCoord.x) / resx*2.0 - 1.0;
  //float y = (gl_FragCoord.y) / resy*2.0 - 1.0;
  float aspectratio = resx/resy;
  //y *= aspectratio;
  
  vec2 qq = gl_FragCoord.xy/vec2(resx,resy);
  vec2 pp = -1.0+2.0*qq;
  //pp.x *= resx/resy;
  float x = pp.x;
  float y = pp.y;

  float t = fs_in.time;

  vec3 v0 = vec3(x, y, 0); // ray intersection with view plane
  //vec3 p = vec3(0, 0.0, -2); // camera position
  //vec3 vd = normalize(v0 - p); // ray direction
	
	vec3 p = campos;
	vec3 vd = camheading;
	vd += camright * tan(30.0) * x * aspectratio;
	vd += camup * tan(30.0) * y;
	vd = normalize(vd);
	vec3 rd = normalize(camheading * 1.67 + camright * x * aspectratio + camup * y);
	vd = rd;
	
  vec3 spherePos = vec3(0, 10.0*cos(t*1.7), 50.0 + 10.0 * sin(t *1.7));
  vec3 lightPos = vec3(70 * cos(fs_in.time * 1.7), 70 * sin(fs_in.time * 0.35), 70 * sin(fs_in.time));

  // epsilon vectors used for calculating surface normals
  float e = 0.001;    
  vec3 dx = vec3(e, 0, 0);
  vec3 dy = vec3(0, e, 0);
  vec3 dz = vec3(0, 0, e);


  // ray marching loop
  bool hit = false;
  float maxZ = 300.0;

  p += vd;
  while (!hit && length(p) < maxZ) {
    float d = dist(p, spherePos);

    if (d <= 0.05) {
      hit = true;
    } else {
      p += vd * d;
    }
  }

  // shading 
  if (hit) {
		
    vec3 n = normalize(vec3(
                            dist(p + dx, spherePos) - dist(p - dx, spherePos),
                            dist(p + dy, spherePos) - dist(p - dy, spherePos),
                            dist(p + dz, spherePos) - dist(p - dz, spherePos)
                            ));

    float light = doLight(vd, p, n, lightPos);

    float fog = clamp(pow(1.1 * p.z / maxZ, 2), 0, 1);
    vec3 fogcol = vec3(0.7, 0.2, 0.2);
		
    color = vec4(mix(vec3(light), fogcol, fog), 1);
    //color = vec4( 0.5-vec3(p.z,p.z,p.z)/maxZ, 1 );
		
  } else {
    color = vec4(0.2, 0.2, 0.2, 1);
  }

}
